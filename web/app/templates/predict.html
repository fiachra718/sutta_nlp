<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NER Predict</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/ner.css') }}">
</head>
<body>

  <h1>NER Predict</h1>
  <p class="meta" id="meta-info"></p>
  <p class="status" id="status"></p>

  <textarea id="text-input" placeholder="Paste text to run through the NER model…"></textarea>
  <div class="controls">
    <button class="primary" type="button" id="run-btn">Run NER</button>
    <button type="button" id="random-btn">Random Verse</button>
    <div class="selection-controls">
      <button type="button" id="add-selection-btn">Add selection</button>
      <label>
        Label
        <select id="add-selection-label"></select>
      </label>
    </div>
    <button type="button" id="clear-btn">Clear</button>
    <button type="button" id="copy-btn">Copy JSON</button>
    <button type="button" id="save-btn">Save to training</button>
    <button type="button" id="save-verse-btn">Save to verse</button>
  </div>

  <section class="panel">
    <h2>Preview</h2>
    <div id="preview">(no text)</div>
  </section>

  <section class="panel" id="entities-panel" hidden>
    <h2>Spans</h2>
    <div class="table-scroll">
      <table class="entities-table">
        <thead>
          <tr>
            <th>#</th>
            <th>Start</th>
            <th>End</th>
            <th>Label</th>
            <th>Text</th>
            <th></th>
          </tr>
        </thead>
        <tbody id="entities-body"></tbody>
      </table>
    </div>
  </section>

  <section class="panel">
    <h2>Raw Output</h2>
    <pre id="raw-json">{}</pre>
  </section>

  <script>
    const INITIAL = {{ initial_doc | default(None) | tojson | safe }};
    const LABEL_COLORS = {
      PERSON: "#bfdbfe",
      GPE: "#bbf7d0",
      LOC: "#fef08a",
      NORP: "#fed7aa",
      EVENT: "#fecdd3",
      UNIT: "#e9d5ff",
    };
    const LABELS = Object.keys(LABEL_COLORS);
    const DEFAULT_LABEL = LABELS[0];

    function clampValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function clamp(value, min, max) {
      return clampValue(value, min, max);
    }

    function toValidLabel(value) {
      const normalized = typeof value === "string" ? value.toUpperCase().trim() : "";
      return LABELS.includes(normalized) ? normalized : DEFAULT_LABEL;
    }

    function escapeHTML(value) {
      return value.replace(/[&<>"']/g, c => ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      }[c]));
    }

    let currentDoc = {
      text: "",
      spans: [],
      meta: null,
    };

    const textInput = document.getElementById("text-input");
    const previewEl = document.getElementById("preview");
    const statusEl = document.getElementById("status");
    const metaEl = document.getElementById("meta-info");
    const rawJsonEl = document.getElementById("raw-json");
    const entitiesPanel = document.getElementById("entities-panel");
    const entitiesBody = document.getElementById("entities-body");
    const addSelectionLabel = document.getElementById("add-selection-label");
    const saveVerseBtn = document.getElementById("save-verse-btn");

    bootstrap();

    document.getElementById("run-btn").addEventListener("click", runNer);
    document.getElementById("clear-btn").addEventListener("click", () => {
      textInput.value = "";
      currentDoc = { text: "", spans: [], meta: null };
      statusEl.textContent = "";
      render();
    });
    document.getElementById("copy-btn").addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(rawJsonEl.textContent);
        statusEl.textContent = "Copied JSON.";
      } catch {
        statusEl.textContent = "Unable to copy.";
      }
    });
    document.getElementById("save-btn").addEventListener("click", saveDoc);
    saveVerseBtn?.addEventListener("click", saveVerse);
    document.getElementById("add-selection-btn").addEventListener("click", addSelectionFromText);
    textInput.addEventListener("input", () => {
      currentDoc.text = textInput.value;
      render();
      updateVerseButtonState();
    });
    populateLabelDropdown(addSelectionLabel);

    function bootstrap() {
      if (INITIAL && typeof INITIAL.text === "string") {
        currentDoc = {
          text: INITIAL.text,
          spans: normalizeSpans(INITIAL.spans, INITIAL.text),
          meta: INITIAL.meta || null,
        };
        textInput.value = INITIAL.text;
      }
      render();
    }

    function populateLabelDropdown(select) {
      if (!select) return;
      select.innerHTML = LABELS.map(label => `<option value="${label}">${label}</option>`).join("");
    }

    async function runNer() {
      const text = textInput.value;
      if (!text.trim()) {
        statusEl.textContent = "Please enter some text.";
        return;
      }
      statusEl.textContent = "Running model…";
      try {
        const response = await fetch("/predict", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text }),
        });
        const payload = await response.json();
        if (!response.ok || payload.ok === false) {
          throw new Error(payload.error || payload.message || "NER failed.");
        }
        const docText = typeof payload.text === "string" ? payload.text : text;
        currentDoc = {
          text: docText,
          spans: normalizeSpans(payload.spans, docText),
          meta: currentDoc.meta,
        };
        textInput.value = docText;
        statusEl.textContent = `Found ${currentDoc.spans.length} span${currentDoc.spans.length === 1 ? "" : "s"}.`;
        render();
        updateVerseButtonState();
      } catch (error) {
        statusEl.textContent = error.message;
      }
    }

    async function saveDoc() {
      let payload;
      try {
        payload = buildPayload();
      } catch (error) {
        statusEl.textContent = error.message;
        return;
      }
      statusEl.textContent = "Saving…";
      try {
        const response = await fetch("/api/training", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        const result = await response.json();
        if (!response.ok || result.ok === false) {
          throw new Error(result.message || result.error || "Save failed.");
        }
        statusEl.textContent = result.message || `Saved as ${result.id}.`;
      } catch (error) {
        statusEl.textContent = error.message;
      }
    }

    function addSelectionFromText() {
      const start = textInput.selectionStart ?? 0;
      const end = textInput.selectionEnd ?? start;
      if (end < start) {
        statusEl.textContent = "Selection end cannot be before start.";
        return;
      }
      const chosenLabel = addSelectionLabel?.value ? toValidLabel(addSelectionLabel.value) : DEFAULT_LABEL;
      const clampedStart = clampValue(start, 0, textInput.value.length);
      const clampedEnd = clampValue(end, clampedStart, textInput.value.length);
      currentDoc.text = textInput.value;
      currentDoc.spans.push({
        start: clampedStart,
        end: clampedEnd,
        label: chosenLabel,
        text: textInput.value.slice(clampedStart, clampedEnd),
      });
      statusEl.textContent = "Added span from selection.";
      render();
      updateVerseButtonState();
    }

    function normalizeSpans(spans, text) {
      if (!Array.isArray(spans)) {
        return [];
      }
      return spans.map(span => {
        const start = clampValue(Number(span.start) || 0, 0, text.length);
        const end = clampValue(Number(span.end) || start, start, text.length);
        const label = toValidLabel(span.label);
        const snippet = span.text || text.slice(start, end);
        return { start, end, label, text: snippet };
      });
    }

    function render() {
      currentDoc.text = textInput.value;
      syncSpanTexts();
      renderPreview();
      renderMeta();
      renderEntities();
      rawJsonEl.textContent = JSON.stringify(currentDoc, null, 2);
    }

    function renderPreview() {
      const text = currentDoc.text || "";
      if (!text) {
        previewEl.textContent = "(no text)";
        return;
      }
      const spans = [...currentDoc.spans].sort((a, b) => a.start - b.start || a.end - b.end);
      let cursor = 0;
      let html = "";
      spans.forEach(span => {
        const start = clampValue(span.start, 0, text.length);
        const end = clampValue(span.end, start, text.length);
        if (start > cursor) {
          html += escapeHTML(text.slice(cursor, start));
        }
        const snippet = escapeHTML(text.slice(start, end));
        const color = LABEL_COLORS[span.label] || "#e5e5e5";
        html += `<span class="tag" style="background:${color}">${snippet} <small>${span.label}</small></span>`;
        cursor = end;
      });
      if (cursor < text.length) {
        html += escapeHTML(text.slice(cursor));
      }
      previewEl.innerHTML = html;
    }

    function renderMeta() {
      if (!currentDoc.meta) {
        metaEl.textContent = "";
        return;
      }
      const parts = [];
      if (currentDoc.meta.identifier) {
        parts.push(currentDoc.meta.identifier);
      }
      if (currentDoc.meta.verse_num !== undefined) {
        parts.push(`v.${currentDoc.meta.verse_num}`);
      }
      metaEl.textContent = parts.join(" — ");
    }

    function renderEntities() {
      const spans = currentDoc.spans;
      if (!spans.length) {
        entitiesBody.innerHTML = "";
        entitiesPanel.hidden = true;
        return;
      }

      const ordered = spans
        .map((span, originalIndex) => ({ span, originalIndex }))
        .sort((a, b) => a.span.start - b.span.start || a.span.end - b.span.end);

      entitiesBody.innerHTML = ordered.map(({ span, originalIndex }, displayIndex) => {
        const displayStart = clampValue(span.start, 0, currentDoc.text.length);
        const displayEnd = clampValue(span.end, displayStart, currentDoc.text.length);
        const displayText = currentDoc.text.slice(displayStart, displayEnd);
        return `
          <tr>
            <td>${displayIndex + 1}</td>
            <td><input type="number" min="0" value="${span.start}" data-idx="${originalIndex}" data-field="start"></td>
            <td><input type="number" min="0" value="${span.end}" data-idx="${originalIndex}" data-field="end"></td>
            <td>
              <select data-idx="${originalIndex}" data-field="label">
                ${LABELS.map(label => `<option value="${label}" ${label === span.label ? "selected" : ""}>${label}</option>`).join("")}
              </select>
            </td>
            <td>${escapeHTML(displayText)}</td>
            <td><button type="button" data-idx="${originalIndex}" data-action="delete">Delete</button></td>
          </tr>
        `;
      }).join("");

      entitiesBody.querySelectorAll("input").forEach(input => {
        input.addEventListener("change", event => {
          const idx = Number(event.target.dataset.idx);
          const key = event.target.dataset.field;
          const value = Number(event.target.value);
          if (!Number.isFinite(idx) || !key) {
            return;
          }
          if (!Number.isFinite(value)) {
            statusEl.textContent = "Offsets must be numeric.";
            return;
          }
          currentDoc.spans[idx][key] = value;
          render();
        });
      });

      entitiesBody.querySelectorAll("select").forEach(select => {
        select.addEventListener("change", event => {
          const idx = Number(event.target.dataset.idx);
          const key = event.target.dataset.field;
          if (!key) {
            return;
          }
          currentDoc.spans[idx][key] = toValidLabel(event.target.value);
          render();
        });
      });

      entitiesBody.querySelectorAll("button[data-action='delete']").forEach(button => {
        button.addEventListener("click", event => {
          const idx = Number(event.target.dataset.idx);
          if (!Number.isFinite(idx)) {
            return;
          }
          currentDoc.spans.splice(idx, 1);
          statusEl.textContent = "Removed span.";
          render();
        });
      });

      entitiesPanel.hidden = false;
    }

    function syncSpanTexts() {
      currentDoc.spans = currentDoc.spans.map(span => {
        const start = Number(span.start);
        const end = Number(span.end);
        const safeStart = Number.isFinite(start) ? start : 0;
        const safeEnd = Number.isFinite(end) ? end : safeStart;
        const label = toValidLabel(span.label);
        const displayStart = clampValue(safeStart, 0, currentDoc.text.length);
        const displayEnd = clampValue(safeEnd, displayStart, currentDoc.text.length);
        return {
          ...span,
          start: safeStart,
          end: safeEnd,
          label,
          text: currentDoc.text.slice(displayStart, displayEnd),
        };
      });
    }

    function buildPayload() {
      currentDoc.text = textInput.value;
      const text = currentDoc.text;
      if (!text.trim()) {
        throw new Error("Nothing to save.");
      }
      const spans = currentDoc.spans.map((span, idx) => {
        const start = Number(span.start);
        const end = Number(span.end);
        if (!Number.isFinite(start) || !Number.isFinite(end)) {
          throw new Error(`Span ${idx + 1} has invalid offsets.`);
        }
        if (start < 0) {
          throw new Error(`Span ${idx + 1} has a negative start.`);
        }
        if (end < start) {
          throw new Error(`Span ${idx + 1} has end < start.`);
        }
        if (end > text.length) {
          throw new Error(`Span ${idx + 1} extends past the text.`);
        }
        const snippet = typeof span.text === "string" && span.text.length
          ? span.text
          : text.slice(start, end);
        return { start, end, label: toValidLabel(span.label), text: snippet };
      });
      return { text, spans };
    }

    function hasVerseMeta() {
      return currentDoc.meta
        && typeof currentDoc.meta.identifier === "string"
        && Number.isInteger(Number(currentDoc.meta.verse_num));
    }

    function updateVerseButtonState() {
      if (!saveVerseBtn) return;
      if (hasVerseMeta()) {
        saveVerseBtn.hidden = false;
        saveVerseBtn.disabled = false;
      } else {
        saveVerseBtn.hidden = true;
        saveVerseBtn.disabled = true;
      }
    }

    async function saveVerse() {
      if (!hasVerseMeta()) {
        statusEl.textContent = "No verse metadata to save.";
        return;
      }
      let payload;
      try {
        payload = buildPayload();
      } catch (error) {
        statusEl.textContent = error.message;
        return;
      }
      const identifier = currentDoc.meta.identifier;
      const verseNum = currentDoc.meta.verse_num;
      statusEl.textContent = "Saving verse…";
      try {
        const response = await fetch(`/api/verse/${encodeURIComponent(identifier)}/${verseNum}/ner`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ spans: payload.spans }),
        });
        const result = await response.json();
        if (!response.ok || result.ok === false) {
          throw new Error(result.message || result.error || "Save failed.");
        }
        statusEl.textContent = result.message || "Saved verse annotations.";
      } catch (error) {
        statusEl.textContent = error.message;
      }
    }

    updateVerseButtonState();

    document.getElementById("random-btn")?.addEventListener("click", () => {
      window.location.href = "{{ url_for('random_verse') }}";
    });
  </script>
</body>
</html>
